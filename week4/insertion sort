想像手上有一副撲克牌，若想要將紙牌從左到右按照「小到大」排序。

Insertion Sort的方法為：將第i張紙牌加入「前i−1張排序過」的紙牌組合，得到i張排序過的紙牌組合。

以圖一為例，從左邊數來的前三張紙牌已經排好序：index(0)、index(1)、index(2)分別為1、3、5，現在要將第四張紙牌(index(3)，數值為2)加入前三張牌，想要得到「前四張排好序」的紙牌組合。
經由觀察，最終結果的紙牌順序為1、2、3、5，可以透過以下步驟完成：

原先index(2)的5搬到index(3)；
原先index(1)的3搬到index(2)；
原先index(3)的2搬到index(1)；

那麼，第i筆資料要怎麼知道其在前1~i−1筆資料之間的順序位置？以圖三為例，當要將array[3]的2，加入array[0]~array[2]的數列時，要怎麼得知，其將被換到array[1]的位置？
就是要透過comparison(比較)。

詳細步驟如下：

現考慮將array[1]的3加入array[1]之前的數列，也就是與array[0]的5，一起形成「排好序」的array[0]~array[1]，見圖四(a)：

定義變數int i為「目前欲處理」的資料的index。
在此i=1，array[i]=3。
定義變數int j來表示「已經排好序」的數列的「最後一個」元素之index。
在此j=0，array[j]=5。
int j會不斷遞減，j--，來檢查array[j]是否比「目前欲處理」的資料還大。
定義變數int key=array[i]，把「目前欲處理」的array[i]以key儲存，避免array[i]被覆蓋掉。
接著，比較key與array[j]的大小，同時確認index(j)沒有超出矩陣範圍。

若key<array[j](並且j>-1)，就表示「目前欲處理」的資料(原先位在index(i)的資料)，比array[j](也就是index(i-1)的資料)還要小，於是將array[j]「往後移」，見圖四(b)：

換位置的方式類似swap()，先執行array[j+1]=array[j]，也就是將原先的array[j]「往後移一個位置」。
在此，把5放進array[1]。
可以預期，原先5在的位置array[0]會被key給補上。如此便完成array[0]~array[1]的排序。
接著，因為不確定前1~i−1筆資料中，是否還有資料比key大，所以執行j--，繼續「往前」比較。
在此例，因為j--後，j等於−1，已經超過矩陣範圍，所以便結束程序。
當兩項條件：j>-1與key<array[j]中，有任何一項條件不滿足時，便表示「已經檢查到前1~i−1筆資料的盡頭」，或是「已經沒有比key還小的資料」，於是便執行array[j+1]=key，把key放回矩陣裡，見圖四(c)。

當不滿足上述兩項條件時，j+1就會是key的位置。
在此，j等於−1，j+1等於0，表示key是1~i筆資料中，最小的資料。
以上步驟，便完成array[0]~array[1]的排序。
