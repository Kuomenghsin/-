二元搜尋樹（英語：Binary Search Tree），也稱為有序二元樹（ordered binary tree）或排序二元樹（sorted binary tree），
是指一棵空樹或者具有下列性質的二元樹：

若任意節點的左子樹不空，則左子樹上所有節點的值均小於它的根節點的值；
若任意節點的右子樹不空，則右子樹上所有節點的值均大於它的根節點的值；
任意節點的左、右子樹也分別為二元搜尋樹；
沒有鍵值相等的節點。
二元搜尋樹相比於其他資料結構的優勢在於尋找、插入的時間複雜度較低。為{\displaystyle O(\log n)}O(\log n)。
二元搜尋樹是基礎性資料結構，用於構建更為抽象的資料結構，如集合、多重集、關聯陣列等。

二元搜尋樹的尋找過程和次優二元樹類似，通常採取二元連結串列作為二元搜尋樹的儲存結構。
中序遍歷二元搜尋樹可得到一個關鍵字的有序序列，一個無序序列可以透過建構一棵二元搜尋樹變成一個有序序列，建構樹的過程即為對無序序列進行尋找的過程。
每次插入的新的結點都是二元搜尋樹上新的葉子結點，在進行插入操作時，不必移動其它結點，只需改動某個結點的指標，
由空變為非空即可。搜尋、插入、刪除的複雜度等於樹高，期望{\displaystyle O(\log n)}O(\log n)，
最壞{\displaystyle O(n)}O(n)（數列有序，樹退化成線性表）。

雖然二元搜尋樹的最壞效率是{\displaystyle O(n)}O(n)，但它支援動態查詢，
且有很多改進版的二元搜尋樹可以使樹高為{\displaystyle O(\log n)}O(\log n)，
從而將最壞效率降至{\displaystyle O(\log n)}O(\log n)，如AVL樹、紅黑樹等。



二元搜尋樹的尋找演算法
在二元搜尋樹b中尋找x的過程為：

1.若b是空樹，則搜尋失敗，否則：
2.若x等於b的根節點的資料域之值，則尋找成功；否則：
3.若x小於b的根節點的資料域之值，則搜尋左子樹；否則：
4.尋找右子樹。

在二元搜尋樹插入節點的演算法
向一個二元搜尋樹b中插入一個節點s的演算法，過程為：

1.若b是空樹，則將s所指節點作為根節點插入，否則：
2.若s->data等於b的根節點的資料域之值，則返回，否則：
3.若s->data小於b的根節點的資料域之值，則把s所指節點插入到左子樹中，否則：
4.把s所指節點插入到右子樹中。（新插入節點總是葉子節點）


在二元搜尋樹刪除結點的演算法

刪除一個有左、右子樹的節點
在二元搜尋樹刪去一個結點，分三種情況討論：

1.若*p結點為葉子結點，即PL（左子樹）和PR（右子樹）均為空樹。由於刪去葉子結點不破壞整棵樹的結構，則只需修改其雙親結點的指標即可。
2.若*p結點只有左子樹PL或右子樹PR，此時只要令PL或PR直接成為其雙親結點*f的左子樹（當*p是左子樹）或右子樹（當*p是右子樹）即可，
作此修改也不破壞二元搜尋樹的特性。
3.若*p結點的左子樹和右子樹均不空。在刪去*p之後，為保持其它元素之間的相對位置不變，可按中序遍歷保持有序進行調整，
可以有兩種做法：其一是令*p的左子樹為*f的左/右（依*p是*f的左子樹還是右子樹而定）子樹，*s為*p左子樹的最右下的結點，
而*p的右子樹為*s的右子樹；其二是令*p的直接前驅（in-order predecessor）或直接後繼（in-order successor）替代*p，
然後再從二元搜尋樹中刪去它的直接前驅（或直接後繼）。
